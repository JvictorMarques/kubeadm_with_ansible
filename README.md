# kubeadm_with_ansible
This repository provides scripts and configuration to automatically deploy a Kubernetes cluster on AWS. The process is fully automated, using Terraform for infrastructure provisioning and Ansible for node configuration and cluster bootstrapping with `kubeadm`.

This project sets up a cluster with the following components:
*   One master node and a configurable number of worker nodes.
*   `containerd` as the container runtime.
*   Calico as the CNI (Container Network Interface) plugin.

## Prerequisites

Before you begin, ensure you have the following installed and configured:
*   [Terraform](https://www.terraform.io/downloads.html)
*   [Ansible](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html)
*   [AWS CLI](https://aws.amazon.com/cli/) with your credentials configured.
*   An SSH key pair located at `~/.ssh/id_rsa.pub` and `~/.ssh/id_rsa`. The public key is used by Terraform to grant you SSH access to the provisioned EC2 instances.

## Quickstart

Follow these steps to provision and configure your Kubernetes cluster.

1.  **Clone the repository:**
    ```bash
    git clone https://github.com/jvictormarques/kubeadm_with_ansible.git
    cd kubeadm_with_ansible
    ```

2.  **Run the startup script:**
    This script automates the entire setup process. It will execute Terraform to build the infrastructure on AWS and then run an Ansible playbook to configure the cluster.

    ```bash
    chmod +x scripts/*.sh
    ./scripts/startup.sh
    ```
    The script performs the following actions:
    - Initializes Terraform.
    - Provisions the AWS resources (VPC, Subnet, EC2 instances, Security Groups, etc.).
    - Generates an Ansible inventory file (`ansible/hosts.ini`) with the public IPs of the new instances.
    - Executes the `ansible/main.yml` playbook to:
        - Install `containerd`, `kubeadm`, `kubectl`, and `kubelet` on all nodes.
        - Initialize the control plane on the master node.
        - Install the Calico network plugin.
        - Join the worker nodes to the cluster.
        - Fetch the `kubeconfig` file to your local machine.

3.  **Access your cluster:**
    After the `startup.sh` script completes, a `kubeconfig` file will be copied to `k8s/config`. You can use this file to manage your new cluster from your local machine.

    Set the `KUBECONFIG` environment variable:
    ```bash
    export KUBECONFIG=$(pwd)/k8s/config
    ```
    Verify that the cluster nodes are ready:
    ```bash
    kubectl get nodes
    ```

## Deploying a Sample Application

A sample NGINX application is provided in `k8s/deployment.yaml` to help you test the cluster.

1.  **Deploy the NGINX application:**
    ```bash
    kubectl apply -f k8s/deployment.yaml
    ```

2.  **Check the status:**
    Verify that the pod is running and the service is created.
    ```bash
    kubectl get pods
    kubectl get svc nginx
    ```
    The output will show the NodePort assigned to the NGINX service, which you can use to access the application.

## Managing the Environment

The `scripts` directory contains helper scripts to manage the cluster's lifecycle.

*   **Destroy the infrastructure (`destroy.sh`):**
    To tear down all AWS resources created by Terraform, run:
    ```bash
    ./scripts/destroy.sh
    ```
*   **Recreate the infrastructure (`recreate.sh`):**
    To destroy and then immediately recreate the entire environment, run:
    ```bash
    ./scripts/recreate.sh
    ```

## Customization

You can customize your deployment by editing the variables in `terraform/vars.tf`. Key variables include:

*   `workers_count`: The number of worker nodes to create (default: `2`).
*   `node_instance`: The AMI ID and instance type for the master and worker nodes (default: `ami-0ecb62995f68bb549` and `t3.small`).
*   `kubeadm_ansible_subnet`: The CIDR block and availability zone for the subnet.

## Project Structure

```
.
├── ansible/          # Ansible playbooks and roles for configuration
│   ├── main.yml      # Main playbook athat orchestrates all roles
│   ├── roles/        # Individual roles for each configuration step
│   └── hosts.ini     # Inventory file auto-generated by Terraform
├── k8s/              # Kubernetes manifests and generated kubeconfig
│   ├── deployment.yaml
│   └── config
├── scripts/          # Helper scripts for managing the environment
│   ├── startup.sh
│   ├── destroy.sh
│   └── recreate.sh
└── terraform/        # Terraform files for AWS infrastructure provisioning
    ├── main.tf
    ├── ec2.tf
    ├── vpc.tf
    └── vars.tf